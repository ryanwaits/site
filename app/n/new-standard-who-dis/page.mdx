import { AnimatedName } from '../animated-name.tsx';

export const metadata = {
  title: 'New Standard, Who Dis?',
  description: 'Standard Schema shipped. Runtime extraction just got universal.',
  alternates: {
    canonical: '/n/new-standard-who-dis',
  },
};

<AnimatedName date="December 2025" />

# New Standard, Who Dis?

Static type analysis can only get you so far.

openpkg extracts API surfaces from TypeScript packages — exports, signatures, types. For most code, the TypeScript compiler API gives accurate results. But validation schemas are different.

A Zod schema like `z.string().email().min(5)` compiles to a TypeScript type of `string`. The constraints — email format, minimum length — exist only at runtime. Static analysis can't see them.

Then [Standard Schema](https://standardschema.dev/) dropped.

## The problem

Validation libraries define rich schemas: string formats, numeric ranges, custom refinements. But each library has its own API:

- Zod: `z.string().email()`
- Valibot: `v.pipe(v.string(), v.email())`
- ArkType: `type("string.email")`

Tools that want to extract schemas need library-specific adapters. Every new validation library means new code. The ecosystem fragments.

## The spec

Standard Schema defines a common interface. Any library can implement `~standard.jsonSchema.output()` to return JSON Schema:

```typescript
// Works for Zod, Valibot, ArkType, TypeBox...
const jsonSchema = schema['~standard'].jsonSchema.output({
  target: 'draft-2020-12'
});
```

One interface. Every library. No adapters.

## What openpkg does now

The `--runtime` flag enables Standard Schema extraction:

```bash
openpkg snapshot src/index.ts --runtime
```

This:

1. Detects available TypeScript runtimes (bun, tsx, Node 22+)
2. Executes the entry file in a subprocess
3. Finds exports implementing `StandardJSONSchemaV1`
4. Calls `~standard.jsonSchema.output()` on each
5. Merges runtime schemas with static type analysis

The output includes which vendor provided each schema:

```json
{
  "name": "UserSchema",
  "schema": {
    "type": "object",
    "properties": {
      "email": { "type": "string", "format": "email" }
    }
  },
  "tags": [
    { "name": "vendor", "text": "zod" },
    { "name": "schema-source", "text": "standard-json-schema" }
  ]
}
```

Static analysis would've given `{ "type": "object" }`. Runtime extraction gives the full picture.

## Hybrid mode

The default is _hybrid_ — merge runtime schemas with static analysis. This catches:

- Validation schemas → rich JSON Schema from runtime
- Plain types → accurate schema from static analysis
- Mixed exports → best of both

```bash
# Just static (fast, no execution)
openpkg snapshot src/index.ts

# Hybrid (static + runtime for validation schemas)
openpkg snapshot src/index.ts --runtime
```

## The timing

Standard Schema shipped in late 2025. openpkg had already chosen JSON Schema as its output format. When the spec dropped, integration was straightforward — the output format already matched what the spec produces.

Pick a standard. When the ecosystem catches up, you're ready.
